#include <stdio.h>#include <string.h>//map保存输入的节点 g是节点间的关系图,d就是prim的时候每个节点父节点到它的值int map[50][50], g[102][102], d[102];char flag[50][50];int X[] = {-1, 0, 1, 0};int Y[] = {0, 1, 0, -1};int n, r, c;struct point{    int x, y, s;} q[50*50];void bfs(int x, int y){    int i, j, tx, ty;    int head, tail;    struct point beg, tn;    beg.x = x, beg.y = y, beg.s = 0;    head = tail = 0;    memset(flag, 0, sizeof(flag));    flag[x][y] = 1;    q[0] = beg;    while (head <= tail)    {        for (i = 0; i < 4; i++)        {            tn = q[head];            tx = tn.x + X[i];            ty = tn.y + Y[i];            if (tx >= 0 && tx < r && ty >= 0 && ty < c && !flag[tx][ty] &&                map[tx][ty] >= 0)            {                flag[tx][ty] = 1;                tn.x = tx, tn.y = ty, tn.s++;                q[++tail] = tn;                if (map[tn.x][tn.y] > 0)                {                    g[map[x][y]][map[tn.x][tn.y]] = tn.s;                    g[map[tn.x][tn.y]][map[x][y]] = tn.s;                }            }        }        head++;    }}void prim(int v, int n){    int i, j, min, sum = 0;    for (i = 1; i <= n; i++)        d[i] = g[v][i];    d[v] = 0;    for (i = 2; i <= n; i++)    {        min = 0xffff;        for (j = 1; j <= n; j++)            if (d[j] > 0 && d[j] < min)                min = d[j], v = j;        sum += d[v];        d[v] = 0;        for (j = 1; j <= n; j++)            if (d[j] > 0 && g[v][j] < d[j])                d[j] = g[v][j];    }    printf("%d\n", sum);}int main(void){    int num;    int i, j;    char tmp[100];    scanf("%d", &n);    while (n--)    {        scanf("%d%d", &c, &r);        gets(tmp);        num = 1;        for (i = 0; i < r; i++)        {            gets(tmp);            for (j = 0; j < c; j++)            {                if (tmp[j] == '#') map[i][j] = -1;                else if (tmp[j] == ' ') map[i][j] = 0;                else if (tmp[j] == 'S') map[i][j] = 1;                else if (tmp[j] == 'A') map[i][j] = ++num;            }        }        memset(g, 0x0f, sizeof(g));        for (i = 0; i < r; i++)            for (j = 0; j < c; j++)                if (map[i][j] > 0)                    bfs(i, j);        prim(1, num);    }    return 0;}
